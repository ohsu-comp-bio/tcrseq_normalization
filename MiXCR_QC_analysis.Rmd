---
title: "MiXCR QC Analysis"
author: "Wes Horton"
date: "May 6, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(grid)
source("http://peterhaschke.com/Code/multiplot.R")
```

## Objective

We need to determine if we can use MiXCR clonotype count outputs as a proxy for depth of coverage. To do so, we need to figure out how reads are aligned and assembled. Are they grouped together too often, what is the reasoning behind the grouping, what happens if we change certain parameters, etc.  

## MiXCR Summary


```{r, echo = FALSE}
# Read in align and assemble QC files
# First is original run
align1 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/mixcr.alignment.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|.assembled.*", '', align1$inputs))
version <- rep("1.6", length(align1$analysis.date))
align1 <- cbind(sample, version, align1)

# second is using mixcr 1.7.1
align2 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/new.mixcr.alignment.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|.assembled.*", '', align2$inputs))
version <- rep("1.7", length(align2$analysis.date))
align2 <- cbind(sample, version, align2)

# third is using mixcr 1.7.1 and paired end reads
align3 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/unPEAR.mixcr.alignment.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|_R.*", '', align3$inputs))
version <- rep("unPEAR_1.7", length(align3$analysis.date))
align3 <- cbind(sample, version, align3)

# Version 4 - equimolar 1.6
align4 <- read.delim("~/Desktop/OHSU/tcr_spike/data/DNA160107LC/QC/mixcr.alignment.QC.summary.txt", sep = ',', header = T)
sample <- as.numeric(gsub(".*S|\\..*", '', align4$inputs))
version <- rep("equimol_1.6", length(align4$analysis.date))
align4 <- cbind(sample, version, align4)

#Combine them
align <- rbind(align1, align2, align3, align4)

# Same for assemble
# Original
assemble1 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/mixcr.assemble.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|_align.*", '', assemble1$inputs))
version <- rep("1.6", length(assemble1$analysis.date))
assemble1 <- cbind(sample, version, assemble1)

# 1.7.1
assemble2 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/new.mixcr.assemble.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|_align.*", '', assemble2$inputs))
version <- rep("1.7", length(assemble2$analysis.date))
assemble2 <- cbind(sample, version, assemble2)

# 1.7.1 and paired end reads
assemble3 <- read.delim("~/Desktop/OHSU/tcr_spike/data/equiv_DNA160107LC/QC/new.mixcr.assemble.QC.summary.txt", sep = ",", header = T)
sample <- as.numeric(gsub(".*S|_align.*", '', assemble3$inputs))
version <- rep("unPEAR_1.7", length(assemble3$analysis.date))
assemble3 <- cbind(sample, version, assemble3)

# 4 - equimolar 1.6
assemble4 <- read.delim("~/Desktop/OHSU/tcr_spike/data/DNA160107LC/QC/mixcr.assemble.QC.summary.txt", header = T, sep = ',')
sample <- as.numeric(gsub(".*S|_align.*", '', assemble4$inputs))
version <- rep("equimol_1.6", length(assemble4$analysis.date))
assemble4 <- cbind(sample, version, assemble4)

# Combine
assemble <- rbind(assemble1, assemble2, assemble3, assemble4)

# Remove sample 142
assemble <- assemble[!(assemble$sample == "142"),]
align <- align[!(align$sample == "142"),]

# Calculate percent of clonotypes eliminated by PCR Error Correction
assemble$total.pot.clones <- assemble$clonotype.count + assemble$clonotypes.elim.error.corr
assemble$pct.lost.to.pcr.corr <- assemble$clonotypes.elim.error.corr / assemble$total.pot.clones * 100


```

#### Alignment

The first command in the MiXCR pipeline is the alignment step. In this step, sequencing reads are aligned to reference (GenBank) V, D, J and C genes of T-cell receptors. We specify the genes of the TRB (T-Cell Receptor Beta chain) locus in our analysis. We use the [**default regions**](http://mixcr.readthedocs.io/en/latest/align.html).

Our analysis pipeline collects the report generated by each align run into a QC summary table. This table contains the following notable columns:


1. Total Reads (in original file)
2. Aligned Reads (number of reads aligned to reference genes)
3. Aligned Percent (reads aligned to reference genes as percent of total reads)
4. Alignment failed because of absence of V hits (as percent of total reads)
5. Alignment failed because of absence of J hits (as percent of total reads)
6. Alignment failed because of low quality score (as percent of total reads)

Below are the results taken from a few different MiXCR runs using the batch 160107LC.

First, lets look at a boxplot of the percentages of aligned reads for each sample as well as a summary of the distribution:


```{r, echo=FALSE}
pct.align <- ggplot(align, aes(x = factor(version), y = aligned.pct, group = version)) + 
  geom_boxplot(aes(fill = version)) #+
  #scale_x_continuous(breaks=NULL) +
  #theme(axis.title.x = element_blank())
pct.align + ylab("Percent Aligned of Total") + ggtitle("160107 Align\nSuccessfully Aligned Reads") +
  xlab("MiXCR Version")
```

The first three use the equivolume sequencing run. 1.6 refers to mixcr version 1.6, 1.7 is version 1.7.1, unPEAR\_1.7 uses unmerged paired-end reads and version 1.7, and equimol_1.6 is equimolar sequencing run using version 1.6

Version 1.6:
```{r, echo = F}
summary(align[align$version == "1.6", 9])
```
Version 1.7.1
```{r, echo = F}
summary(align[align$version == "1.7", 9])
```
Unassembled reads, version 1.7.1
```{r, echo = F}
summary(align[align$version == "unPEAR_1.7", 9])
```
Equimolar sequencing, version 1.6
```{r, echo = F}
summary(align[align$version == "equimol_1.6", 9])
```

We see that most of the samples aligned greater than 80% of their reads, but a few have relatively poor alignments, with one extreme outlier in the unassembled reads run. We can look at a few of the explanatory columns to see why the rest aren't aligning.

```{r, echo = FALSE}
pct.low.score <- ggplot(align, aes(x = version, y = failed.alignment.low.score,
                                   group = version)) +
  geom_boxplot(aes(fill = version)) +
  #scale_x_continuous(breaks=NULL) +
  theme(axis.title.x = element_blank()) +
  ylab("Percent Not Aligned of Total") + 
  xlab("MiXCR Version") +
  ggtitle("160107 Align\nFailed Alignment Due to Low Score")

failed.j <- ggplot(align, aes(x = version, y = failed.alignment.j.hits,
                              group = version)) +
  geom_boxplot(aes(fill = version)) +
  #scale_x_continuous(breaks=NULL) +
  #theme(axis.title.x = element_blank()) + 
  ylab("Percent Not Aligned of Total") + 
  xlab("MiXCR Version") +
  ggtitle("Failed Alignment Due to Absence of J Hit")

multiplot(pct.low.score, failed.j, cols=1)
```

##### Failed Due to Low Score:  

Version 1.6:
```{r, echo = F}
summary(align[align$version == "1.6", 13])
```
Version 1.7.1
```{r, echo = F}
summary(align[align$version == "1.7", 13])
```
Unassembled reads, version 1.7.1
```{r, echo = F}
summary(align[align$version == "unPEAR_1.7", 13])
```
Equimolar sequencing, version 1.6
```{r, echo = F}
summary(align[align$version == "equimol_1.6", 13])
```

##### Failed Due to No J Hit:  

Version 1.6:
```{r, echo = F}
summary(align[align$version == "1.6", 12])
```
Version 1.7.1
```{r, echo = F}
summary(align[align$version == "1.7", 12])
```
Unassembled reads, version 1.7.1
```{r, echo = F}
summary(align[align$version == "unPEAR_1.7", 12])
```
Equimolar sequencing, version 1.6
```{r, echo = F}
summary(align[align$version == "equimol_1.6", 12])
```

Looks like most reads are not aligning due to a lack of J hit. This is a little concerning. In theory, all reads assembled by PEAR should have both V and J regions. This is because we use a V primer as our forward primer and a J as our reverse. After PEAR assembly, they should be on either end of the same read.

Does this mean we have off-target amplification? Are V primers binding where we should have J binding? Is PEAR mis-assembling our reads?

Should we relax the parameters for calling a hit? 

##### Moving Forward
1. Perform primer specificity experiment - amplify synthetic templates with 1 V primer and all J primers, repeating for each V primer. Repeat process with 1 J primer and all V primers.
     + See figure 3 of Carlson et al. 2013 - "Using synthetic templates to design an unbiased multiplex PCR assay"

2. Extract all unaligned reads, and re-run them through MiXCR align using relaxed parameters.
     + use -a to save the description line from fastq file. 
     + Export alignments with descriptions
     + remove all aligned reads from fastq file
     + re-run remaining reads with relaxed parameters
     + See if we align more of remaining reads

#### Assemble

After reads are aligned to reference genes, the assemble command extracts specific gene regions (CDR3 in our case) and builds a set of clones. 

1. Assembler extracts clonal sequence (CDR3) from read

     A) Read dropped if lacking clonal sequence
     B) Read deferred to mapping if contains at least 1 low-quality nucleotide
     C) Read dropped if contains too many low-quality nucleotides (.7% of total)
     D) Read retained as core clonotype if it has CDR3 and high quality nucleotides
     
2. Assembler builds core clonotypes by grouping reads from section 1D that have identical clonal sequence (CDR3). Two important properties:

     A) Clonal sequence (CDR3 identity)
     B) Count - number of reads of this clonotype
     
3. Assembler maps deferred reads (1B) to core clonotypes

     A) Deferred read is aggregated to a core clonotype if it has a "fuzzy" match
          + What is fuzzy match? Can't find in docs
          + Possibly same as parameters for clustering
     B) If read matches multiple core clonotypes, one is chosen at random based on their abundances
     C) Read dropped if it doesn't match any core clonotype
     
4. Assembler clusters core clonotypes based on abundances

     A) Finds fuzzy matches between core clonotypes
          + Default allows 1 mutation in N regions in order to cluster
               + N regions are VD, DJ, and VJ junctions
          + Default allows 2 mismatches or indels between clones in different tree layers
               + parent and direct child
               + total of 2
     B) Aggregates into a hierarchical tree based on relative abundances
          + Head clone has highest abundance
          + Child layer 1 has almost identical sequence and an order of magnitude (or 2 or 3) fewer counts than head clone
          + Child layer 2 has almost identical sequence to Child 1 and an order of magnitude (or 2 or 3) fewer counts than Child 1
    C) Only head clones are considered final clones and only those counts are used.
    D) Align clonal sequences to reference V, D, J, and C genes

Our analysis pipeline collects the report generated by each pipeline and aggregates them into a QC summary. Notable columns that provide information on assembly:

1. Clonotype Count - how many (unique?) clonotypes identified
2. Total Reads Used in Assembly
3. Percent Reads Used (percent of total)
4. Percent Reads Used as Core Clonotypes (percent of reads used)
5. Low quality reads successfully mapped (percent of reads used)
6. Reads clustered in PCR error correction (percent of reads used)
7. Clonotypes eliminated by PCR error correction
8. Reads dropped due to lack of clonal sequence (percent of total)
9. Reads dropped due to low quality score (percent of total)
10. Reads dropped due to failed mapping (percent of total)

```{r, echo = FALSE}
pct.assemble <- ggplot(assemble, aes(x = version, y = pct.total.reads.used, 
                                     group = version)) +
  geom_boxplot(aes(fill = version)) +
  #scale_x_continuous(breaks=NULL) +
  #theme(axis.title.x = element_blank()) + 
  ylab("Percent Reads Used of Total") +
  xlab("MiXCR Version") +
  ggtitle("160107 Assemble\nAssembled Reads")

pct.core <- ggplot(assemble, aes(x = version, y = pct.reads.used.as.core, group = version)) +
  geom_boxplot(aes(fill = version)) +
  #scale_x_continuous(breaks=NULL) +
  #theme(axis.title.x = element_blank()) + 
  ylab("Reads Used for Core (Percent of Reads Used)") + 
  xlab("MiXCR Version") +
  ggtitle("160107 Assemble\nAssembled Reads Used as Core Clones")

pct.mapped <- ggplot(assemble, aes(x = version, y = pct.reads.used.mapped.low.quality,
                                   group = version)) +
  geom_boxplot(aes(fill = version)) +
  ylab("Reads Successfully Mapped (Percent of Used)") +
  xlab("MiXCR Version") +
  ggtitle("160107 Assemble\nLow Quality Reads Mapped to Core Clones")

pct.failed.mapped <- ggplot(assemble, aes(x = version, y = pct.reads.dropped.failed.mapping,
                                          group = version)) +
  geom_boxplot(aes(fill = version)) +
  ylab("Reads Not Mapped (Percent of Used") +
  xlab("MiXCR Version") +
  ggtitle("Low Quality Reads Failing to Map")

pct.no.clonotype <- ggplot(assemble, aes(x = version, 
                                         y = pct.reads.dropped.no.clonal.sequence,
                                         group = version)) +
  geom_boxplot(aes(fill = version)) +
  #scale_x_continuous(breaks=NULL) +
  #theme(axis.title.x = element_blank()) + 
  ylab("Percent Dropped of Total") + 
  xlab("MiXCR Version") +
  ggtitle("160107 Assemble\nReads Dropped Due to No Clonal Sequence")

clon.elim.error <- ggplot(assemble, aes(x = pct.lost.to.pcr.corr)) +
  geom_histogram(aes(fill = version)) +
  #scale_x_continuous(breaks=seq(0, 16000, by = 2000)) +
  facet_grid(version ~ .) +
  #theme(axis.title.x = element_blank()) + 
  #ylab("Percent") + 
  xlab("Percent lost to PCR Error Correction")
  ggtitle("160107 Assemble\nClonotypes eliminated by PCR Error Correction")

pct.assemble
```
Version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "1.6", 9])
```
Version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "1.7", 9])
```
Unassembled reads, version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "unPEAR_1.7", 9])
```
Equimolar sequencing, version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "equimol_1.6", 9])
```
This is concerning that not very many reads are assembled into clonotypes. We can look at some of the reasons that MiXCR gives us to see if we can figure out why.

```{r, echo = F}
pct.core
```
Version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "1.6", 10])
```
Version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "1.7", 10])
```
Unassembled reads, version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "unPEAR_1.7", 10])
```
Equimolar sequencing, version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "equimol_1.6", 10])
```
Here we see that most of the reads that are used are core clonotypes, meaning they have high sequence quality and contain CDR3 sequences. So what happened to the rest of the reads assembled, but not identified as a core clone?

```{r, echo = F}
multiplot(pct.mapped, pct.failed.mapped)
```

###### Summary for Percent Mapped

Version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "1.6", 11])
```
Version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "1.7", 11])
```
Unassembled reads, version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "unPEAR_1.7", 11])
```
Equimolar sequencing, version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "equimol_1.6", 11])
```

Looks like almost all reads that were deferred for mapping successfully mapped back to the core clonotypes. One would think that there should be a few reads that are deferred that are unable to be mapped back. Does this suggest that our alignment parameters are too strict so that we're eliminating too many reads? We can look at the various reasons for dropped reads to get some clues.

```{r, echo = F}
pct.no.clonotype
```
Version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "1.6", 14])
```
Version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "1.7", 14])
```
Unassembled reads, version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "unPEAR_1.7", 14])
```
Equimolar sequencing, version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "equimol_1.6", 14])
```
These results are puzzling. If around 80% of our reads are aligning to V and J regions, one would assume that they would also contain a CDR3 region to be extracted. According to one of the developers, assembly is just clustering records into clonotypes and all "markup" is done at the alignment step. That still doesn't fit with our high alignment percentages and low assembly percentages though.  

##### Moving Forward

We need to determine where the problem of read dropping is occurring. These reports suggest somewhere in the assembly step (because of the high alignment percentages), but the information on how MiXCR runs suggests that the important part of clone identification actually occurs when reads are aligned. 

1. Use IMGT library instead of GenBank and see if that increases our assembly percentages
2. Leverage exported clones file to map back to raw reads somehow?
     + Need to do some more thinking on this.
     

A few extra plots

```{r, echo = F}
clon.elim.error
```
Version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "1.6", 13])
```
Version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "1.7", 13])
```
Unassembled reads, version 1.7.1:
```{r, echo = F}
summary(assemble[assemble$version == "unPEAR_1.7", 13])
```
Equimolar sequencing, version 1.6:
```{r, echo = F}
summary(assemble[assemble$version == "equimol_1.6", 13])
```

These histograms show the percentage of clonotypes lost during the clustering stage. We can see that most are pretty negligible, although a non-trivial amount of our samples are losing 20-60% of clonotypes because of this clustering.

##### Moving Forward

We can turn off clustering completely as well as alter its parameters. The one problem is that we don't know if these clonotypes that we're losing are real clonotypes or if the program is correctly identifying PCR errors and they're actually erroneous clonotypes. Need to do some more thinking on this. Also may not be relevant right now because our assembly percentage is a more important problem

#### Export

We can export alignments and assemblies to tab-separated files for manual and programmatic inspection. I need to take a look at the outputs of these files and see how we might be able to leverage them to help solve some of these problems. Can maybe see if alignment is capturing D regions or not, as well as in assembly. More to come.