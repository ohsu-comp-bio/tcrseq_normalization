---
title: "Independence of V and J Primers"
author: "Wes Horton, Burcu Gurun-Demir"
date: "May 4, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
```

## Summary of Dataset and Purpose

We have approximately 170 samples per sequencing batch, and for each sample we have 260 counts, one for each of the unique combinations of V and J primers. The primers have different amplification rates, which we need to characterize. In order to do this most accurately, we need to determine if the forward (V) primer and the reverse (J) primer act independently to influence spike amplification, or if their interaction is important as well.  

Two different PCR batches comprise our sequencing batch. There may be a difference in amplification biases based on these batches as well. In addition, samples were diluted by varying degrees prior to sequencing, and we need to determine if that had an influence.  

### Variables

1. Independent variables
    + Forward (V) primer identity - 20 total
    + Reverse (J) primer identity - 13 total
    + PCR batch identity - 2 total
    + Tape Station dilution factor  
  
  
2. Dependent variable
    + Spike Count  


Each sample has an individual file containing the 260 counts. These need to be combined into a single data frame prior to the analysis.

```{r cars}
# Set directory
count.dir <- "~/Desktop/OHSU/tcr_spike/data/vj_counts/DNA150826/"

# Read in files and sort by sample number
all.counts <- list.files(count.dir)
all.counts <- all.counts[order(as.numeric(gsub(".*_S|.assembled.*", '', all.counts)))]

# Read in first file to start aggregate data frame
count.df <- read.table(file.path(count.dir, all.counts[1]), sep =',', header = T)
count.df <- count.df[,3:5]

# Comine spike counts for all files into 1 data frame
  # Columns are samples
  # Rows are spikes
for (i in 2:length(all.counts)){
  curr.df <- read.table(file.path(count.dir, all.counts[i]), sep = ',', header = T)
  count.df <- cbind(count.df, curr.df$spike.count)
}   #   for i in 2:length(new.counts)
colnames(count.df) <- c("V", "J", seq(1:length(all.counts)))

head(count.df[,1:10], n = 20)

# Collapse data frame to 1 count column
melt.count.df <- melt(count.df, id.vars = c("V", "J"))

# Take log2 of count values due to geometric distribution
log2.melt.count.df <- melt.count.df
log2.melt.count.df$value <- log2(melt.count.df$value + 1)

head(log2.melt.count.df, n = 20)
# V is all V segments, repeated for each J for each sample
# J is all J segments, repeated same as V
# Variable corresponds to sample number
# Value is log2 of count
```

## Linear Regression Model

We want to create a linear regression model in order to test the interaction effect between V and J primers on spike counts. First we'll show an additive model, then a multiplicative model.

```{r}
# Additive Model
add.lm <- lm(value ~ V + J, log2.melt.count.df)
summary(add.lm)
add.adj.r2 <- round(summary(add.lm)$adj.r.squared, digits = 4)

# Multiplicative Model
mult.lm <- lm(value ~ V * J, log2.melt.count.df)
summary(mult.lm)
mult.adj.r2 <- round(summary(mult.lm)$adj.r.squared, digits = 4)
paste("Additive R^2:", add.adj.r2, sep = ' ')
paste("Multiplicative R^2:", mult.adj.r2, sep = ' ')
```

We can see that the multiplicative model explains more variation than the additive. Now we should look at specific V/J pairs to see if there are any specific combinations that are contributing to this increase.

```{r}
start <- lm(value ~ 1, log2.melt.count.df)
summary(start)
finish <- lm(value ~ V * J , log2.melt.count.df)
summary(finish)
test <- step(mult.lm, scope = list(lower = start, upper = finish), direction = "forward")
summary(test)
test$anova
test2 <- step(mult.lm, scope = list( ~., finish), direction = "forward")
test2$anova

```


Also going to do a chi squared test. Need to format the data so that we have V's as rows and J's as columns

```{r}
#row.col <- paste(count.df$V, count.df$J, sep = '')
#chi.sq.df2 <- data.frame(matrix(nrow = length(row.col), ncol = length(row.col)))
#rownames(chi.sq.df2) <- row.col
#colnames(chi.sq.df2) <- row.col

vs <- unique(count.df$V)
js <- unique(count.df$J)
chi.sq.df <- data.frame(matrix(nrow = length(vs), ncol = length(js)))
rownames(chi.sq.df) <- vs
colnames(chi.sq.df) <- js

subset.count <- count.df[,3:169]
sum.of.rows <- apply(subset.count, 1, sum)

new.count <- cbind(count.df[,1:2], sum.of.rows)

for (i in 1:length(new.count$sum.of.rows)){
  v <- as.character(new.count[i,1])
  j <- as.character(new.count[i,2])
  sum <- new.count[i,3]
  rownum <- which(v == row.names(chi.sq.df))
  colnum <- which(j == colnames(chi.sq.df))
  chi.sq.df[rownum,colnum] <- sum 
}

chisq.test(chi.sq.df, correct = F)
